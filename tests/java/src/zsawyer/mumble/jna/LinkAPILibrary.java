/* Copyright (C) 2013, zsawyer <zsawyer@users.sourceforge.net>

 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions
 are met:

 - Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
 this list of conditions and the following disclaimer in the documentation
 and/or other materials provided with the distribution.
 - Neither the name of the Mumble Developers nor the names of its
 contributors may be used to endorse or promote products derived from this
 software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR
 CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package zsawyer.mumble.jna;

import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.Structure;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.FloatBuffer;
import java.util.Arrays;
import java.util.List;

/**
 * JNA Wrapper for library <b>LinkAPI</b><br>
 * This file was autogenerated by <a
 * href="http://jnaerator.googlecode.com/">JNAerator</a>, a tool written by <a
 * href="http://ochafik.com/">Olivier Chafik</a> that <a
 * href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few
 * opensource projects.</a> For help, please visit <a
 * href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a
 * href="http://rococoa.dev.java.net/">Rococoa</a>, or <a
 * href="http://jna.dev.java.net/">JNA</a>.
 *
 * @author cleaned up by zsawyer, 2013
 */
public interface LinkAPILibrary extends Library {

	public static final String JNA_LIBRARY_NAME = "LinkAPI";
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.
			getInstance(LinkAPILibrary.JNA_LIBRARY_NAME);
	public static final LinkAPILibrary INSTANCE = (LinkAPILibrary) Native.
			loadLibrary(LinkAPILibrary.JNA_LIBRARY_NAME, LinkAPILibrary.class);

	/**
	 * error codes hinting at the root cause of a failure
	 */
	public static interface ErrorCode {

		/**
		 * no error<br>
		 * <i>native declaration : line 55</i>
		 */
		public static final int ERROR_CODE_NO_ERROR = 0;
		/**
		 * win32 specific: OpenFileMappingW failed to return a handle<br>
		 * <i>native declaration : line 57</i>
		 */
		public static final int ERROR_CODE_WIN32_NO_HANDLE = 1;
		/**
		 * win32 specific: MapViewOfFile failed to return a structure<br>
		 * <i>native declaration : line 59</i>
		 */
		public static final int ERROR_CODE_WIN32_NO_STRUCTURE = 2;
		/**
		 * unix specific: shm_open returned a negative integer<br>
		 * <i>native declaration : line 61</i>
		 */
		public static final int ERROR_CODE_UNIX_NO_HANDLE = 3;
		/**
		 * unix specific: mmap failed to return a structure<br>
		 * <i>native declaration : line 63</i>
		 */
		public static final int ERROR_CODE_UNIX_NO_STRUCTURE = 4;
		/**
		 * shared memory was not initialized<br>
		 * <i>native declaration : line 65</i>
		 */
		public static final int ERROR_CODE_NO_MEMORY_WAS_INITIALIZED = 5;
		/**
		 * the provided context length was out of bounds<br>
		 * <i>native declaration : line 67</i>
		 */
		public static final int ERROR_CODE_CONTEXT_LENGTH_EXCEEDED = 6;
	};
	public static final int VECTOR_LENGTH = 3;
	public static final int MAX_IDENTITY_LENGTH = 256;
	public static final int MAX_NAME_LENGTH = 256;
	public static final int MAX_CONTEXT_LENGTH = 256;
	public static final int MAX_DESCRIPTION_LENGTH = 2048;
	public static final int UI_VERSION_UNLINK = 0;

	public static class LinkedMem extends Structure {

		public int uiVersion;
		public int uiTick;
		/** C type : float[3] */
		public float[] fAvatarPosition = new float[VECTOR_LENGTH];
		/** C type : float[3] */
		public float[] fAvatarFront = new float[VECTOR_LENGTH];
		/** C type : float[3] */
		public float[] fAvatarTop = new float[VECTOR_LENGTH];
		/** C type : wchar_t[256] */
		public char[] name = new char[MAX_NAME_LENGTH];
		/** C type : float[3] */
		public float[] fCameraPosition = new float[VECTOR_LENGTH];
		/** C type : float[3] */
		public float[] fCameraFront = new float[VECTOR_LENGTH];
		/** C type : float[3] */
		public float[] fCameraTop = new float[VECTOR_LENGTH];
		/** C type : wchar_t[256] */
		public char[] identity = new char[MAX_IDENTITY_LENGTH];
		public int context_len;
		/** C type : unsigned char[256] */
		public byte[] context = new byte[MAX_CONTEXT_LENGTH];
		/** C type : wchar_t[2048] */
		public char[] description = new char[MAX_DESCRIPTION_LENGTH];

		public LinkedMem() {
			super();
		}

		protected List<?> getFieldOrder() {
			return Arrays.asList("uiVersion", "uiTick", "fAvatarPosition",
					"fAvatarFront", "fAvatarTop", "name", "fCameraPosition",
					"fCameraFront", "fCameraTop", "identity", "context_len",
					"context", "description");
		}

		public static class ByReference extends LinkedMem implements
				Structure.ByReference {
		};

		public static class ByValue extends LinkedMem implements
				Structure.ByValue {
		};
	};

	/**
	 * initialize the linked memory
	 * and set the name and description
	 *
	 * it corresponds to initMumble() defined here:
	 * http://mumble.sourceforge.net/Link
	 * but also sets the name and description as this should only needed to be
	 * set once
	 *
	 * @param name	       the display name of the application which links with
	 *                       mumble (i.e. L"TestLink")
	 * @param description	a text stating the purpose of this link
	 * @param uiVersion	  no description available (this should usually be set
	 *                       to 2)
	 *
	 * @return	an error code {@link ErrorCode}
	 */
	/* Original signature :
	 * <code>ErrorCode initialize(wchar_t[256], wchar_t[2048], int)</code><br>
	 * <i>native declaration : line 85</i>
	 */
	int initialize(CharBuffer name, CharBuffer description, int uiVersion);

	/**
	 * forcefully unlinks the plugin instantly
	 *
	 * this function directly circumvents the timeout wait of the link plugin
	 *
	 * this effect is undone when calling an update method or
	 * {@link #initialize(java.nio.CharBuffer, java.nio.CharBuffer, int)}
	 */
	/* Original signature :
	 * <code>void doUnlink()</code><br>
	 * <i>native declaration : line 97</i>
	 */
	void doUnlink();

	/**
	 * notifies the plugin that the data is up-to-date update...-functions call
	 * this method at the end
	 *
	 * this is to prevent a timeout which causes the plugin to automatically
	 * unlink
	 *
	 * @return an error code {@link ErrorCode}
	 */
	/* Original signature :
	 * <code>ErrorCode commit()</code><br>
	 * <i>native declaration : line 108</i>
	 */
	int commit();

	/**
	 * sets and commits the identity
	 *
	 * Notice: The identity does not need to be updated every single frame. It
	 * shouldn't change more than a few times per second if at all during a
	 * game.
	 *
	 * see {@link #setIdentity(java.nio.CharBuffer)} for details
	 *
	 * @param identity	unique id of the user in a given context
	 *
	 * @return an error code {@link ErrorCode}
	 *
	 */
	/* Original signature :
	 * <code>ErrorCode updateIdentity(wchar_t[256])</code><br>
	 * <i>native declaration : line 123</i>
	 */
	int updateIdentity(CharBuffer identity);

	/**
	 * get the client's identity
	 *
	 * see {@link #setIdentity(java.nio.CharBuffer)} for details
	 *
	 * @return the client's identity
	 */
	/* Original signature :
	 * <code>wchar_t* getIdentity()</code><br>
	 * <i>native declaration : line 131</i>
	 */
	CharBuffer getIdentity();

	/**
	 * set the identity only
	 *
	 * Notice: The identity does not need to be updated every single frame. It
	 * shouldn't change more than a few times per second if at all during a
	 * game.
	 *
	 * Identity should contain a string which uniquely identifies the player in
	 * the given context. This is usually satisfied by the in-game player name
	 * or the players ID (player-/connection-ID on the server or a global ID).
	 *
	 * Additionally the identity can contain any additional information about
	 * the player that might be interesting for the mumble server.
	 *
	 * We recommend using an easily parseable format like JSON or CSV for
	 * encoding the information but this is up to the game. Remember that the
	 * link structures only allow for limited characters of identity data.
	 *
	 * @param identity	unique id of the user in a given context
	 *
	 * @return	an error code {@link ErrorCode}
	 */
	/* Original signature :
	 * <code>ErrorCode setIdentity(wchar_t[256])</code><br>
	 * <i>native declaration : line 155</i>
	 */
	int setIdentity(CharBuffer identity);

	/**
	 * sets and commits the context
	 *
	 * Notice: The context does not need to be updated every single frame. It
	 * shouldn't change more than a few times per second if at all during a
	 * game.
	 *
	 * see
	 * {@link #setContext(java.nio.ByteBuffer, int)} for details
	 *
	 * @param context	    a generic context
	 * @param context_len	the length of the context (number of array elements)
	 *
	 * @return an error code {@link ErrorCode}
	 */
	/* Original signature :
	 * <code>ErrorCode updateContext(unsigned char[256], int)</code><br>
	 * <i>native declaration : line 171</i>
	 */
	int updateContext(ByteBuffer context, int context_len);

	/**
	 * getter for the client's context
	 * see
	 * {@link #setContext(java.nio.ByteBuffer, int)} for details
	 *
	 * @return the client's context
	 *
	 */
	/* Original signature :
	 * <code>unsigned char* getContext()</code><br>
	 * <i>native declaration : line 180</i>
	 */
	ByteBuffer getContext();

	/**
	 * sets the context
	 *
	 * Notice: The context does not need to be updated every single frame. It
	 * shouldn't change more than a few times per second if at all during a
	 * game.
	 *
	 * The context string is used to determine which users on a Mumble server
	 * should hear each other positionally. If context between two mumble user
	 * does not match the positional audio data is stripped server-side and
	 * voice will be received as non-positional.
	 *
	 * Accordingly the context should only match for players on the same server
	 * in the same game on the same map. Whether to include things like team in
	 * this string depends on the game itself. When in doubt err on the side of
	 * including less. This gives more flexibility later on.
	 *
	 * @param context	    a generic context
	 * @param context_len	the length of the context (number of array elements)
	 *
	 * @return an error code {@link ErrorCode}
	 *
	 */
	/* Original signature :
	 * <code>ErrorCode setContext(unsigned char[], int)</code><br>
	 * <i>native declaration : line 204</i>
	 */
	int setContext(ByteBuffer context, int context_len);

	/**
	 * the length of the context (number of array elements)
	 *
	 * @return the length of the current context
	 *
	 */
	/* Original signature :
	 * <code>int getContextLen()</code><br>
	 * <i>native declaration : line 206</i>
	 */
	int getContextLen();

	/**
	 * sets and commits the identity AND context
	 *
	 * Notice: The identity and/or context does not need to be updated every
	 * single frame. It shouldn't change more than a few times per second if at
	 * all during a game.
	 *
	 * see
	 * {@link #setIdentity(java.nio.CharBuffer)} and
	 * {@link #setContext(java.nio.ByteBuffer, int)} for detailed information
	 *
	 * @param identity	   unique id of the user
	 * @param context	    a generic context
	 * @param context_len	the length of the context (number of active array
	 *                       elements)
	 *
	 * @return an error code {@link ErrorCode}
	 *
	 */
	/* Original signature :
	 * <code>ErrorCode updateIdentityAndContext(wchar_t[256], unsigned char[256], int)</code><br>
	 * <i>native declaration : line 225</i>
	 */
	int updateIdentityAndContext(CharBuffer identity, ByteBuffer context,
			int context_len);

	/**
	 * sets the identity AND context
	 *
	 * Notice: The identity and/or context does not need to be updated every
	 * single frame. It shouldn't change more than a few times per second if at
	 * all during a game.
	 *
	 * see
	 * {@link #setIdentity(java.nio.CharBuffer)} and
	 * {@link #setContext(java.nio.ByteBuffer, int)} for detailed informations
	 *
	 * @param identity	   unique id of the user
	 * @param context	    a generic context
	 * @param context_len	the length of the context (number of active array
	 *                       elements)
	 *
	 * @return an error code {@link ErrorCode}
	 *
	 */
	/* Original signature :
	 * <code>ErrorCode setIdentityAndContext(wchar_t[], unsigned char[], int)</code><br>
	 * <i>native declaration : line 247</i>
	 */
	int setIdentityAndContext(CharBuffer identity, ByteBuffer context,
			int context_len);

	/**
	 * sets and commits the name
	 *
	 * Notice: This does not need to be updated every single frame. It shouldn't
	 * change at all during a game.
	 *
	 * see
	 * {@link #setName(java.nio.CharBuffer)} for details
	 *
	 * @param name	the display name of the application which links with mumble
	 *                (i.e. L"TestLink")
	 *
	 * @return an error code {@link ErrorCode}
	 *
	 */
	/* Original signature :
	 * <code>ErrorCode updateName(wchar_t[256])</code><br>
	 * <i>native declaration : line 262</i>
	 */
	int updateName(CharBuffer name);

	/**
	 * the display name of the application currently linked with mumble
	 * see
	 * {@link #setName(java.nio.CharBuffer)} for details
	 *
	 * @return application name
	 *
	 */
	/* Original signature :
	 * <code>wchar_t* getName()</code><br>
	 * <i>native declaration : line 264</i>
	 */
	CharBuffer getName();

	/**
	 * sets the name only
	 *
	 * Notice: This does not need to be updated every single frame. It shouldn't
	 * change at all during a game.
	 *
	 * this name is shown in the mumble interface to indicate which plugin's
	 * positional audio is being used (i.e. used for the "XXX linked." message
	 * in the mumble log)
	 *
	 * @param name	the display name of the application which links with mumble
	 *                (i.e. L"TestLink")
	 *
	 * @return an error code {@link ErrorCode}
	 *
	 */
	/* Original signature :
	 * <code>ErrorCode setName(wchar_t[256])</code><br>
	 * <i>native declaration : line 281</i>
	 */
	int setName(CharBuffer name);

	/**
	 * sets and commits the description
	 *
	 * Notice: This does not need to be updated every single frame. It shouldn't
	 * change at all during a game.
	 *
	 * see
	 * {@link #setDescription(java.nio.CharBuffer)} for details
	 *
	 * @param description	a text stating the purpose of this link
	 *
	 * @return an error code {@link ErrorCode}
	 *
	 */
	/* Original signature :
	 * <code>ErrorCode updateDescription(wchar_t[2048])</code><br>
	 * <i>native declaration : line 296</i>
	 */
	int updateDescription(CharBuffer description);

	/**
	 * the linked applications description
	 * see
	 * {@link #setDescription(java.nio.CharBuffer)} for details
	 *
	 * @return a text stating the purpose of this link
	 *
	 */
	/* Original signature :
	 * <code>wchar_t* getDescription()</code><br>
	 * <i>native declaration : line 298</i>
	 */
	CharBuffer getDescription();

	/**
	 * sets the description only
	 *
	 * Notice: This does not need to be updated every single frame. It shouldn't
	 * change at all during a game.
	 *
	 * this is the text to explain the plugin and its purpose
	 *
	 * @param description	a text stating the purpose of this link
	 *
	 * @return an error code {@link ErrorCode}
	 *
	 */
	/* Original signature :
	 * <code>ErrorCode setDescription(wchar_t[2048])</code><br>
	 * <i>native declaration : line 313</i>
	 */
	int setDescription(CharBuffer description);

	/**
	 * updates and commits the avatar and camera vectors
	 *
	 * Notice: Mumble fetches these values 50 times a second, so please update
	 * them every frame.
	 *
	 * @param fAvatarPosition	Position of the avatar.
	 * @param fAvatarFront	   Unit vector pointing out of the avatar's eyes.
	 * @param fAvatarTop	     Unit vector pointing out of the top of the
	 *                           avatar's head.
	 * @param fCameraPosition	Position of the camera.
	 * @param fCameraFront	   Unit vector pointing out of the camera's lense.
	 * @param fCameraTop	     Unit vector pointing out of the camera's top.
	 *
	 * @return an error code {@link ErrorCode}
	 *
	 */
	/* Original signature :
	 * <code>ErrorCode updateVectors(float[3], float[3], float[3], float[3], float[3], float[3])</code><br>
	 * <i>native declaration : line 331</i>
	 */
	int updateVectors(FloatBuffer fAvatarPosition, FloatBuffer fAvatarFront,
			FloatBuffer fAvatarTop, FloatBuffer fCameraPosition,
			FloatBuffer fCameraFront, FloatBuffer fCameraTop);

	/**
	 * sets avatar and camera vectors
	 *
	 * Notice: Mumble fetches these values 50 times a second, so please update
	 * them every frame.
	 *
	 * @param fAvatarPosition	Position of the avatar.
	 * @param fAvatarFront	   Unit vector pointing out of the avatar's eyes.
	 * @param fAvatarTop	     Unit vector pointing out of the top of the
	 *                           avatar's head.
	 * @param fCameraPosition	Position of the camera.
	 * @param fCameraFront	   Unit vector pointing out of the camera's lense.
	 * @param fCameraTop	     Unit vector pointing out of the camera's top.
	 *
	 * @return an error code {@link ErrorCode}
	 *
	 */
	/* Original signature :
	 * <code>ErrorCode setVectors(float[3], float[3], float[3], float[3], float[3], float[3])</code><br>
	 * <i>native declaration : line 355</i>
	 */
	int setVectors(FloatBuffer fAvatarPosition, FloatBuffer fAvatarFront,
			FloatBuffer fAvatarTop, FloatBuffer fCameraPosition,
			FloatBuffer fCameraFront, FloatBuffer fCameraTop);

	/**
	 * updates and commits avatar AND camera vectors with the same values
	 *
	 * Notice: Mumble fetches these values 50 times a second, so please update
	 * them every frame.
	 *
	 * see
	 * {@link #setVectorsByAvatar(java.nio.FloatBuffer, java.nio.FloatBuffer, java.nio.FloatBuffer)}
	 * for details
	 *
	 * @param fAvatarPosition	Position of the avatar and camera.
	 * @param fAvatarFront	   Unit vector pointing out of the camera/avatar's
	 *                           eyes.
	 * @param fAvatarTop	     Unit vector pointing out of the top of the
	 *                           avatar's head/camera's top.
	 *
	 * @return an error code {@link ErrorCode}
	 */
	/* Original signature :
	 * <code>ErrorCode updateVectorsByAvatar(float[3], float[3], float[3])</code><br>
	 * <i>native declaration : line 378</i>
	 */
	int updateVectorsByAvatar(FloatBuffer fAvatarPosition,
			FloatBuffer fAvatarFront, FloatBuffer fAvatarTop);

	/**
	 * sets avatar AND camera vectors with the same values
	 *
	 * this simply reuses the given vectors for the camera
	 *
	 * short cut function to use when the camera of the game/program is not
	 * independent of the avatar
	 *
	 * Notice: Mumble fetches these values 50 times a second, so please update
	 * them every frame.
	 *
	 * see the respective single vector setters for details
	 *
	 * @param fAvatarPosition	Position of the avatar and camera.
	 * @param fAvatarFront	   Unit vector pointing out of the camera/avatar's
	 *                           eyes.
	 * @param fAvatarTop	     Unit vector pointing out of the top of the
	 *                           avatar's head/camera's top.
	 *
	 * @return an error code {@link ErrorCode}
	 *
	 */
	/* Original signature :
	 * <code>ErrorCode setVectorsByAvatar(float[3], float[3], float[3])</code><br>
	 * <i>native declaration : line 403</i>
	 */
	int setVectorsByAvatar(FloatBuffer fAvatarPosition, FloatBuffer fAvatarFront,
			FloatBuffer fAvatarTop);

	/**
	 * The position of the avatar
	 *
	 * location of the avatar or avatar's head where it is located in the 3D
	 * game world
	 *
	 * @return a 3D vector
	 *
	 */
	/* Original signature :
	 * <code>float* getAvatarPosition()</code><br>
	 * <i>native declaration : line 416</i>
	 */
	FloatBuffer getAvatarPosition();

	/**
	 * The position of the avatar
	 *
	 * location of the avatar or avatar's head where it is located in the 3D
	 * game world
	 *
	 * @param x the magnitude of the x basis vector
	 * @param y the magnitude of the y basis vector
	 * @param z the magnitude of the z basis vector
	 *
	 * @return an error code {@link ErrorCode}
	 *
	 */
	/* Original signature :
	 * <code>ErrorCode setAvatarPosition(float, float, float)</code><br>
	 * <i>native declaration : line 429</i>
	 */
	int setAvatarPosition(float x, float y, float z);

	/**
	 * Unit vector pointing out of the avatar's eyes
	 *
	 * indicates the direction the avatar or avatar's head is pointing at
	 *
	 * @return a 3D vector (look vector)
	 *
	 */
	/* Original signature :
	 * <code>float* getAvatarFront()</code><br>
	 * <i>native declaration : line 439</i>
	 */
	FloatBuffer getAvatarFront();

	/**
	 * Unit vector pointing out of the avatars eyes
	 *
	 * indicates the direction the avatar or avatar's head is pointing at
	 *
	 * Note: this vector should be perpendicular to the top vector
	 *
	 * @param x the magnitude of the x basis vector
	 * @param y the magnitude of the y basis vector
	 * @param z the magnitude of the z basis vector
	 *
	 * @return an error code {@link ErrorCode}
	 *
	 */
	/* Original signature :
	 * <code>ErrorCode setAvatarFront(float, float, float)</code><br>
	 * <i>native declaration : line 454</i>
	 */
	int setAvatarFront(float x, float y, float z);

	/**
	 * Unit vector pointing out of the top of the avatar's head
	 *
	 * indicates the direction that the top of the avatar or
	 * avatar's head is pointing at
	 *
	 * @return a 3D vector (the avatar's up vector)
	 *
	 */
	/* Original signature :
	 * <code>float* getAvatarTop()</code><br>
	 * <i>native declaration : line 465</i>
	 */
	FloatBuffer getAvatarTop();

	/**
	 * Unit vector pointing out of the top of the avatar's head
	 *
	 * indicates the direction that the top of the avatar or
	 * avatar's head is pointing at
	 *
	 * Note: this vector should be perpendicular to the front vector
	 *
	 * @param x the magnitude of the x basis vector
	 * @param y the magnitude of the y basis vector
	 * @param z the magnitude of the z basis vector
	 *
	 * @return an error code {@link ErrorCode}
	 *
	 */
	/* Original signature :
	 * <code>ErrorCode setAvatarTop(float, float, float)</code><br>
	 * <i>native declaration : line 481</i>
	 */
	int setAvatarTop(float x, float y, float z);

	/**
	 * The position of the camera
	 *
	 * location of the camera where it is located in the 3D game world
	 *
	 * @return a 3D vector
	 *
	 */
	/* Original signature :
	 * <code>float* getCameraPosition()</code><br>
	 * <i>native declaration : line 491</i>
	 */
	FloatBuffer getCameraPosition();

	/**
	 * The position of the camera
	 *
	 * location of the camera where it is located in the 3D game world
	 *
	 * @param x the magnitude of the x basis vector
	 * @param y the magnitude of the y basis vector
	 * @param z the magnitude of the z basis vector
	 *
	 * @return an error code {@link ErrorCode}
	 *
	 */
	/* Original signature :
	 * <code>ErrorCode setCameraPosition(float, float, float)</code><br>
	 * <i>native declaration : line 504</i>
	 */
	int setCameraPosition(float x, float y, float z);

	/**
	 * Unit vector pointing out of the front/lens of the camera
	 *
	 * indicates the direction the camera is pointing at
	 *
	 * @return a 3D vector (look vector)
	 *
	 */
	/* Original signature :
	 * <code>float* getCameraFront()</code><br>
	 * <i>native declaration : line 514</i>
	 */
	FloatBuffer getCameraFront();

	/**
	 * Unit vector pointing out of the front/lens of the camera
	 *
	 * indicates the direction the camera is pointing at
	 *
	 * Note: this vector should be perpendicular to the top vector
	 *
	 * @param x the magnitude of the x basis vector
	 * @param y the magnitude of the y basis vector
	 * @param z the magnitude of the z basis vector
	 *
	 * @return an error code {@link ErrorCode}
	 *
	 */
	/* Original signature :
	 * <code>ErrorCode setCameraFront(float, float, float)</code><br>
	 * <i>native declaration : line 529</i>
	 */
	int setCameraFront(float x, float y, float z);

	/**
	 * Unit vector pointing out of the top of the camera
	 *
	 * indicates the direction that the top of the camera is pointing at
	 *
	 * @return a 3D vector (the camera's up vector)
	 *
	 */
	/* Original signature :
	 * <code>float* getCameraTop()</code><br>
	 * <i>native declaration : line 539</i>
	 */
	FloatBuffer getCameraTop();

	/**
	 * Unit vector pointing out of the top of the camera
	 *
	 * indicates the direction that the top of the camera is pointing at
	 *
	 * Note: this vector should be perpendicular to the front vector
	 *
	 * @param x the magnitude of the x basis vector
	 * @param y the magnitude of the y basis vector
	 * @param z the magnitude of the z basis vector
	 *
	 * @return an error code {@link ErrorCode}
	 *
	 */
	/* Original signature :
	 * <code>ErrorCode setCameraTop(float, float, float)</code><br>
	 * <i>native declaration : line 554</i>
	 */
	int setCameraTop(float x, float y, float z);

	/**
	 */
	/* Original signature :
	 * <code>int getUiVersion()</code><br>
	 * <i>native declaration : line 557</i>
	 */
	int getUiVersion();

	/**
	 */
	/* Original signature :
	 * <code>ErrorCode setUiVersion(int)</code><br>
	 * <i>native declaration : line 559</i>
	 */
	int setUiVersion(int version);

	/**
	 */
	/* Original signature :
	 * <code>ErrorCode updateUiVersion(int)</code><br>
	 * <i>native declaration : line 561</i>
	 */
	int updateUiVersion(int version);

	/**
	 * tick counter which is used to tell if updates to the shared memory occur
	 *
	 * if this number stays the same no the rest of the shared memory is not
	 * read
	 * and the link plugin will unlink after a certain timeout
	 *
	 * @return the last tick number
	 *
	 */
	/* Original signature :
	 * <code>DWORD getUiTick()</code><br>
	 * <i>native declaration : line 572</i>
	 */
	int getUiTick();

	/**
	 * tick counter which is used to tell if updates to the shared memory occur
	 *
	 * if this number stays the same the rest of the shared memory is not read
	 * and the link plugin will unlink after a certain timeout
	 *
	 * @param tick the tick number to set
	 *
	 * @return an error code {@link ErrorCode}
	 *
	 */
	/* Original signature :
	 * <code>ErrorCode setUiTick(DWORD)</code><br>
	 * <i>native declaration : line 584</i>
	 */
	int setUiTick(int tick);

	/**
	 * tick counter which is used to tell if updates to the shared memory occur
	 *
	 * if this number stays the same the rest of the shared memory is not read
	 * and the link plugin will unlink after a certain timeout
	 *
	 * @param tick the tick number to set
	 *
	 * @return an error code {@link ErrorCode}
	 *
	 */
	/* Original signature :
	 * <code>ErrorCode updateUiTick(DWORD)</code><br>
	 * <i>native declaration : line 596</i>
	 */
	int updateUiTick(int tick);

	/**
	 * directly manipulate the entire linked memory at once
	 *
	 * IMPORTANT: Note that you should also update uiTick yourself, else a
	 * timeout
	 * will occur and your data will not be read. Subsequently calling the
	 * commit()-function once will not help when uiTick is always set to the
	 * same
	 * value.
	 *
	 * Notice: Parts of this does not need to be updated every single frame.
	 * Please use the more directly appropriate update functions instead.
	 *
	 * @param source data structure which is to be copied
	 *
	 * @return an error code {@link ErrorCode}
	 *
	 */
	/* Original signature :
	 * <code>ErrorCode setData(LinkedMem*)</code><br>
	 * <i>native declaration : line 614</i>
	 */
	int setData(LinkAPILibrary.LinkedMem source);

	/**
	 * the entire shared memory for direct access
	 *
	 * @return a pointer to the shared memory structure
	 *
	 */
	/* Original signature :
	 * <code>LinkedMem* getData()</code><br>
	 * <i>native declaration : line 622</i>
	 */
	LinkAPILibrary.LinkedMem getData();
}
